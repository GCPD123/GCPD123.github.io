---
title: springIoc
date: 2019-12-22 11:06:15
tags: spring
category: java框架
---

## 工厂类

工厂类主要解决类之间的依赖问题，只是减少依赖而不能完全消除，一个工厂首先要能生产类（根据配置文件创建出类）然后在根据用户需要获取出类（根据唯一名称获取出相关类）

1. 首先要有配置文件，就是告诉工厂首先要生产（通过反射创建）出什么类

   ![](1.png)

   properties类专门加载配置文件，通过类加载器的getResourceAsStream()方法可以直接加载类路径下的配置文件，作为输入流，所谓类路径实际就是**编译后目标文件的**目录结构中的根目录

   ![](2.png)

   classes就是类路径的根目录也就是说源代码中src和resources目录下所有内容都会原封不动的进入类路径中所以放在resources目录下的配置文件就相当于在编译后的类路径下

   因为加载配置文件是在工厂类一运行后就加载一次，所以放在静态代码块中最好，静态代码块随着类的加载而运行，且只运行一次，**注意：静态代码块只能引用静态变量，因为只有静态才在同一个时间加载**

2. 加载配置文件后就可以创建获取对象的方法，通过传入相应的唯一id来通过反射创建对象

   ```java
   public object getBean(String beanName){
     String beanPath = properties.getPropery(beanName);
     object bean = Class.forName(beanPath).newInstance();
   }
   ```

   也就是根据唯一id从配置文件中取出该类的全限定类名，然后通过反射创建对象。

### 工厂类升级

上面工厂类的不足：每次通过读取配置文件得出类名然后通过反射创建的对象是多例的，也就是每次对象不一样

解决方法：将创建出来的对象保存起来，需要用的时候直接拿出来，这就需要用到一个“容器”来存储对象，也就是spring的核心容器（实际是一个map集合）

![](3.png)

静态代码块中要做的是

1. 创建配置文件对象和集合对象
2. 读取配置文件，将所有类加载

![](4.png)

将所有的key取出来，一个一个的通过反射创建对象，然后存储到map中

然后方法中要做的



![](5.png)

从map中取出来即可，特点是：工厂类一加载就会将配置文件中的所有类都通过反射创建出来然后存储到map中，也就是说是提前加载，不管你需不需要，然后需要的类直接从map中取出来，就不用通过配置文件了，这样对象就只创建了一次，也就保证了唯一性

### springIoc

springIoc即是spring的核心容器，他是存储配置文件中所有类的容器，在容器中创建对象，然后直接向容器中索取对象

首先通过maven创建spring工程依赖：

![](6.png)

![](7.png)

其中aop是注解需要的类



配置文件就相当于工厂中的properties

![](8.png)

配置的<bean>标签中的内容就是自动创建并且存储到容器中的类，需要的话直接从容器中取出即可

> 该标签中的类会通过反射创建，且是通过该类的空参造方法创建，如果没有空参构造方法，则创建失败会报错



![](9.png)

通过ApplicationContext对象来获取容器，其中实现类的作用是读取类路径下的配置文件，**配置文件一读取，则spring容器就会初始化，其中所有的类都会自动创建且存入核心容器中**

