---
title: springIoc
date: 2019-12-22 11:06:15
tags: spring
category: java框架
---

## 工厂类

工厂类主要解决类之间的依赖问题，只是减少依赖而不能完全消除，一个工厂首先要能生产类（根据配置文件创建出类）然后在根据用户需要获取出类（根据唯一名称获取出相关类）

1. 首先要有配置文件，就是告诉工厂首先要生产（通过反射创建）出什么类

   ![](1.png)

   properties类专门加载配置文件，通过类加载器的getResourceAsStream()方法可以直接加载类路径下的配置文件，作为输入流，所谓类路径实际就是**编译后目标文件的**目录结构中的根目录

   ![](2.png)

   classes就是类路径的根目录也就是说源代码中src和resources目录下所有内容都会原封不动的进入类路径中所以放在resources目录下的配置文件就相当于在编译后的类路径下

   因为加载配置文件是在工厂类一运行后就加载一次，所以放在静态代码块中最好，静态代码块随着类的加载而运行，且只运行一次，**注意：静态代码块只能引用静态变量，因为只有静态才在同一个时间加载**

2. 加载配置文件后就可以创建获取对象的方法，通过传入相应的唯一id来通过反射创建对象

   ```java
   public object getBean(String beanName){
     String beanPath = properties.getPropery(beanName);
     object bean = Class.forName(beanPath).newInstance();
   }
   ```

   也就是根据唯一id从配置文件中取出该类的全限定类名，然后通过反射创建对象。

### 工厂类升级

上面工厂类的不足：每次通过读取配置文件得出类名然后通过反射创建的对象是多例的，也就是每次对象不一样

解决方法：将创建出来的对象保存起来，需要用的时候直接拿出来，这就需要用到一个“容器”来存储对象，也就是spring的核心容器（实际是一个map集合）

![](3.png)

静态代码块中要做的是

1. 创建配置文件对象和集合对象
2. 读取配置文件，将所有类加载

![](4.png)

将所有的key取出来，一个一个的通过反射创建对象，然后存储到map中

然后方法中要做的



![](5.png)

从map中取出来即可，特点是：工厂类一加载就会将配置文件中的所有类都通过反射创建出来然后存储到map中，也就是说是提前加载，不管你需不需要，然后需要的类直接从map中取出来，就不用通过配置文件了，这样对象就只创建了一次，也就保证了唯一性

### springIoc

springIoc即是spring的核心容器，他是存储配置文件中所有类的容器，在容器中创建对象，然后直接向容器中索取对象

首先通过maven创建spring工程依赖：

![](6.png)

![](7.png)

其中aop是注解需要的类



配置文件就相当于工厂中的properties

![](8.png)

配置的<bean>标签中的内容就是自动创建并且存储到容器中的类，需要的话直接从容器中取出即可

> 该标签中的类会通过反射创建，且是通过该类的空参造方法创建，如果没有空参构造方法，则创建失败会报错



![](9.png)

通过ApplicationContext对象来获取容器，其中实现类的作用是读取类路径下的配置文件，**配置文件一读取，则spring容器就会初始化，其中所有的类都会自动创建且存入核心容器中**

### 创建bean的三种方式

1. 通过<bean>标签创建，该标签的意思是将class属性中的类通过反射创建该类，然后存入到容器中，使用的时候通过id属性取出来**注意，是使用该类的空参构造方法创建**，如果没有空参构造方法则创建失败

![](10.png)

2. 通过普通工厂创建，有些类是在jar包中别人写好的类都是字节码文件无法修改，也不确定有没有默认构造函数，也就不能通过<bean>的方式创建，无法通过配置的方法创建并存入容器，就可以通过一个工厂类，手动创建该需要的类

![](12.png)

![](11.png)

通过指定工厂的类和方法来创建对象，但是首先要把工厂类存入容器，然后配置需要的类，告诉容器应该如何创建（通过工厂类的一个方法创建，并存入容器中）

3. 上面工厂类中的方法可能是静态方法，使用某个类中的静态方法创建对象，并存入容器

![](13.png)

![](14.png)

前两个属性的意思是：创建staticFactory类，以accountService名字存入容器，但是我们需要的AccountService类的对象，所以要告诉该工厂通过静态方法创建出该类然后存入容器

### 依赖注入

两个类之间的依赖，比如在A类中有age name date三个成员变量，这三个就称为依赖，因为如果没有这三个，则该类不完整，所以叫依赖。依赖注入：将实际值传递到变量中

常用注入方法为set注入，成员变量必须要有set方法才能注入

![](15.png)

![](16.png)

![](17.png)

因为依赖是在具体的类中，所以配置是在<bean>标签中，**告诉spring容器，创建这个类的时候这些变量应该是什么值**，其中name属性是指定变量的名称，准确说是指定set方法后面的名称，如setName()和setname()两个方法的name属性值分别是Name和name,**注意不是成员变量名字，虽然大多数情况下都相同**



value属性表示希望注入的值，**注意由于value后面都是有双引号，所以值的类型都是字符串**如age是Integer类型的变量，但是注入是“18”spring会自动进行类型转换，将字符串类型转换为其他所有能够转换的类型。value只能提供基本类型和string类型的数据



ref属性表示引用容器中其他的类，值为其他bean的id



### 注解配置

注解的分类：

1. 用于创建对象 和<bean>功能一样
2. 用于注入数据 和<property>功能一样，**但是注解注入就不需要set方法**
3. 用于改变作用范围 和<scop>功能一样
4. 和生命周期相关 和<init-method>功能一样

首先启用注解功能需要导入约束

![](18.png)

context就是注解的约束，注意选中部分也是要导入的，一个功能有两份地址“context”和“xsd”

使用注解要在文件中配置

![](19.png)

告诉spring表示扫描的包

1. 创建对象的注解

![](20.png)

表示以反射创建该对象（默认构造方法，也就是空参）并以首字母小写为id存入容器中，可以以该id取出来。

注解中如果只有一个value属性则该value属性可以不写，直接写值，比如“accountService”表示通过反射创建该类并以accountService为id存入容器中

2. 依赖注入的注解

有两种：@Autowired和@value前者只能注入容器中已存在的bean，后者可以注入基本类型和string，而且是从文件中读取

@Autowired表示只以**类型**在容器中查找相同类的对象并赋值给该变量

![](21.png)

自动找AccountDao类的对象，**注意实现了AccountDao接口的对象也算是该类**，所以可能会有多个，如果找到多个，则根据变量名决定，如果容器中有id为accountDao的对象则注入。**所以使用注解注入不需要set方法**

![](22.png)

![](23.png)

value注入直接在属性中写入值即可注入，但是只能是基本类型和string类型，由于Date类型不是基本类型，所以无法通过value注入

![](24.png)

![](25.png)

Date可以这样注入创建到容器中，再通过Aurowired取出

### Spring中的junit测试

原本junit测试中集成了一个main方法，在该main方法中会判断当前测试类中哪些方法会有@test注解，junit就会让其执行，但junit不会管我们用的什么框架，也就不会加载spring容器，所以要整合spring和junit

1. 导入整合后的包

![](26.png)

2. 替换当前junit运行环境，把原来junit本身的main方法替换成spring提供的，run注解就是替换运行期

![](27.png)

3. 告知spring的运行器，是基于注解还是xml配置的，并说明位置

![](28.png)







